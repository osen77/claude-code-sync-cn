//! Wrapper script management
//!
//! This module handles creation and management of wrapper scripts
//! that pull history before starting Claude Code.

use anyhow::{Context, Result};
use colored::Colorize;
use std::path::PathBuf;

#[cfg(unix)]
use std::os::unix::fs::PermissionsExt;

/// Unix wrapper script content
const UNIX_WRAPPER_SCRIPT: &str = r#"#!/bin/bash
# Claude Code Sync Wrapper
# Auto-generated by claude-code-sync
#
# This script pulls the latest conversation history before starting Claude Code.
# Use this instead of 'claude' to ensure you have the latest history.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Pull latest history before starting Claude (silent, non-blocking on error)
"$SCRIPT_DIR/claude-code-sync" pull --quiet 2>/dev/null || true

# Start Claude Code with all arguments
exec claude "$@"
"#;

/// Windows batch wrapper script content
#[allow(dead_code)]
const WINDOWS_BAT_WRAPPER_SCRIPT: &str = r#"@echo off
REM Claude Code Sync Wrapper
REM Auto-generated by claude-code-sync
REM
REM This script pulls the latest conversation history before starting Claude Code.
REM Use this instead of 'claude' to ensure you have the latest history.

set SCRIPT_DIR=%~dp0

REM Pull latest history before starting Claude (silent, non-blocking on error)
"%SCRIPT_DIR%claude-code-sync.exe" pull --quiet 2>nul

REM Start Claude Code with all arguments
claude %*
"#;

/// Windows PowerShell wrapper script content
#[allow(dead_code)]
const WINDOWS_PS1_WRAPPER_SCRIPT: &str = r#"# Claude Code Sync Wrapper
# Auto-generated by claude-code-sync
#
# This script pulls the latest conversation history before starting Claude Code.
# Use this instead of 'claude' to ensure you have the latest history.

$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path

# Pull latest history before starting Claude (silent, non-blocking on error)
try {
    & "$scriptDir\claude-code-sync.exe" pull --quiet 2>$null
} catch {
    # Ignore errors
}

# Start Claude Code with all arguments
& claude @args
"#;

/// Get the directory where claude-code-sync is installed
fn get_install_dir() -> Result<PathBuf> {
    std::env::current_exe()?
        .parent()
        .map(|p| p.to_path_buf())
        .context("Cannot determine install directory")
}

/// Get the wrapper script path for Unix systems
fn get_unix_wrapper_path() -> Result<PathBuf> {
    Ok(get_install_dir()?.join("claude-sync"))
}

/// Get the wrapper script path for Windows batch
#[allow(dead_code)]
fn get_windows_bat_wrapper_path() -> Result<PathBuf> {
    Ok(get_install_dir()?.join("claude-sync.bat"))
}

/// Get the wrapper script path for Windows PowerShell
#[allow(dead_code)]
fn get_windows_ps1_wrapper_path() -> Result<PathBuf> {
    Ok(get_install_dir()?.join("claude-sync.ps1"))
}

/// Install wrapper script(s)
pub fn handle_wrapper_install(force: bool) -> Result<PathBuf> {
    println!("{}", "Creating wrapper script(s)...".cyan().bold());

    let install_dir = get_install_dir()?;
    println!("Install directory: {}", install_dir.display());

    #[cfg(unix)]
    {
        let wrapper_path = get_unix_wrapper_path()?;
        install_unix_wrapper(&wrapper_path, force)?;
        Ok(wrapper_path)
    }

    #[cfg(windows)]
    {
        let bat_path = get_windows_bat_wrapper_path()?;
        let ps1_path = get_windows_ps1_wrapper_path()?;
        install_windows_wrappers(&bat_path, &ps1_path, force)?;
        Ok(bat_path)
    }
}

#[cfg(unix)]
fn install_unix_wrapper(wrapper_path: &PathBuf, force: bool) -> Result<()> {
    if wrapper_path.exists() && !force {
        println!(
            "  {} Wrapper already exists: {}",
            "!".yellow(),
            wrapper_path.display()
        );
        println!("  Use '--force' to overwrite.");
        return Ok(());
    }

    std::fs::write(wrapper_path, UNIX_WRAPPER_SCRIPT)?;

    // Make executable
    let mut perms = std::fs::metadata(wrapper_path)?.permissions();
    perms.set_mode(0o755);
    std::fs::set_permissions(wrapper_path, perms)?;

    println!(
        "  {} Created: {}",
        "✓".green(),
        wrapper_path.display()
    );

    Ok(())
}

#[cfg(windows)]
fn install_windows_wrappers(bat_path: &PathBuf, ps1_path: &PathBuf, force: bool) -> Result<()> {
    // Install .bat wrapper
    if bat_path.exists() && !force {
        println!(
            "  {} Batch wrapper already exists: {}",
            "!".yellow(),
            bat_path.display()
        );
    } else {
        std::fs::write(bat_path, WINDOWS_BAT_WRAPPER_SCRIPT)?;
        println!("  {} Created: {}", "✓".green(), bat_path.display());
    }

    // Install .ps1 wrapper
    if ps1_path.exists() && !force {
        println!(
            "  {} PowerShell wrapper already exists: {}",
            "!".yellow(),
            ps1_path.display()
        );
    } else {
        std::fs::write(ps1_path, WINDOWS_PS1_WRAPPER_SCRIPT)?;
        println!("  {} Created: {}", "✓".green(), ps1_path.display());
    }

    if !force && (bat_path.exists() || ps1_path.exists()) {
        println!("  Use '--force' to overwrite existing files.");
    }

    Ok(())
}

/// Uninstall wrapper script(s)
pub fn handle_wrapper_uninstall() -> Result<()> {
    println!("{}", "Removing wrapper script(s)...".cyan().bold());

    let mut removed = false;

    #[cfg(unix)]
    {
        let wrapper_path = get_unix_wrapper_path()?;
        if wrapper_path.exists() {
            std::fs::remove_file(&wrapper_path)?;
            println!("  {} Removed: {}", "✓".green(), wrapper_path.display());
            removed = true;
        }
    }

    #[cfg(windows)]
    {
        let bat_path = get_windows_bat_wrapper_path()?;
        let ps1_path = get_windows_ps1_wrapper_path()?;

        if bat_path.exists() {
            std::fs::remove_file(&bat_path)?;
            println!("  {} Removed: {}", "✓".green(), bat_path.display());
            removed = true;
        }

        if ps1_path.exists() {
            std::fs::remove_file(&ps1_path)?;
            println!("  {} Removed: {}", "✓".green(), ps1_path.display());
            removed = true;
        }
    }

    if !removed {
        println!("{}", "No wrapper scripts found to remove.".yellow());
    }

    Ok(())
}

/// Show wrapper script status
pub fn handle_wrapper_show() -> Result<()> {
    println!("{}", "Wrapper Script Status".cyan().bold());

    let install_dir = get_install_dir()?;
    println!("Install directory: {}", install_dir.display());
    println!();

    #[cfg(unix)]
    {
        let wrapper_path = get_unix_wrapper_path()?;
        if wrapper_path.exists() {
            println!("{}", "Wrapper script: INSTALLED".green());
            println!("  Path: {}", wrapper_path.display().to_string().cyan());
            println!();
            println!("Usage:");
            println!("  {} [args]", "claude-sync".cyan());
            println!();
            println!("Or add an alias to your shell profile:");
            println!("  alias claude='{}'", wrapper_path.display());
        } else {
            println!("{}", "Wrapper script: NOT installed".yellow());
            println!();
            println!(
                "Run '{}' to create the wrapper.",
                "claude-code-sync wrapper install".cyan()
            );
        }
    }

    #[cfg(windows)]
    {
        let bat_path = get_windows_bat_wrapper_path()?;
        let ps1_path = get_windows_ps1_wrapper_path()?;

        let bat_exists = bat_path.exists();
        let ps1_exists = ps1_path.exists();

        if bat_exists || ps1_exists {
            println!("{}", "Wrapper scripts: INSTALLED".green());
            if bat_exists {
                println!("  Batch: {}", bat_path.display().to_string().cyan());
            }
            if ps1_exists {
                println!("  PowerShell: {}", ps1_path.display().to_string().cyan());
            }
            println!();
            println!("Usage:");
            if bat_exists {
                println!("  {} [args]", "claude-sync".cyan());
            }
            if ps1_exists {
                println!("  {} [args]", ".\\claude-sync.ps1".cyan());
            }
        } else {
            println!("{}", "Wrapper scripts: NOT installed".yellow());
            println!();
            println!(
                "Run '{}' to create the wrappers.",
                "claude-code-sync wrapper install".cyan()
            );
        }
    }

    Ok(())
}

/// Check if wrapper is installed
pub fn is_wrapper_installed() -> Result<bool> {
    #[cfg(unix)]
    {
        Ok(get_unix_wrapper_path()?.exists())
    }

    #[cfg(windows)]
    {
        Ok(get_windows_bat_wrapper_path()?.exists() || get_windows_ps1_wrapper_path()?.exists())
    }
}

/// Get the primary wrapper path (for display purposes)
pub fn get_wrapper_path() -> Result<PathBuf> {
    #[cfg(unix)]
    {
        get_unix_wrapper_path()
    }

    #[cfg(windows)]
    {
        get_windows_bat_wrapper_path()
    }
}
